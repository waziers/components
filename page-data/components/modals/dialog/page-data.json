{"componentChunkName":"component---src-layout-documentation-tsx","path":"/components/modals/dialog/","result":{"data":{"site":{"siteMetadata":{"title":"Looker UI Components"}},"mdx":{"id":"8e7349e4-cd4f-5b48-9de1-7f51267ded92","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dialog\",\n  \"propsOf\": \"Dialog\",\n  \"github\": \"Modal/Dialog/Dialog\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(Banner, {\n    intent: \"warning\",\n    mdxType: \"Banner\"\n  }, \"Dialog provides a general purpose (empty & unstyled) modal overlay.\", ' ', mdx(\"a\", {\n    href: \"/components/modals/confirm\"\n  }, \"Confirm\"), \" will likely be more useful if your intent is to render a standard user confirmation dialog.\"), mdx(\"p\", null, \"Dialogs break out of the standard application flow and UI to present new information or required actions.\"), mdx(\"h2\", null, \"Standard Use\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Dialog\"), \" requires that the developer manages state by assigning \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \" to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isOpen\"), \" prop.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \";() => {\\n  const { value, setOn, setOff } = useToggle()\\n  return (\\n    <div>\\n      <Dialog isOpen={value} onClose={() => setOff()}>\\n        <ModalContent>\\n          <Paragraph>Some content inside the Dialog</Paragraph>\\n          <Button>A button too!</Button>\\n        </ModalContent>\\n      </Dialog>\\n      <Button onClick={() => setOn()}>Open Dialog</Button>\\n    </div>\\n  )\\n}\\n\")), mdx(\"h2\", null, \"DialogManager\"), mdx(\"p\", null, \"DialogManager gives an easy way to compose a Dialog without the need to manage open/close state.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"<DialogManager\\n  content={\\n    <ModalContent>\\n      <Paragraph>Some content inside the Dialog</Paragraph>\\n      <Button>A button too!</Button>\\n    </ModalContent>\\n  }\\n>\\n  {onClick => <Button onClick={onClick}>Open Dialog </Button>}\\n</DialogManager>\\n\")), mdx(\"h2\", null, \"Props: width and maxWidth\"), mdx(\"p\", null, \"All variants of Dialog allow you to override \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"width\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"max-width\"), \" styles to suit your content. By default, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"width\"), \" is unassigned so that Dialog Surface will conform to the width of its content. At the same time, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxWidth\"), \" constrains the Dialog surface's width to be no larger than the specified value.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxWidth\"), \" defaults to one of three sizes depending on the responsive breakpoint of the page (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"['90vw', '90vw', '600px']\"), \").\"), mdx(\"p\", null, \"With those constraints in mind, if you want a variable-width Dialog that renders complex content you should use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxWidth\"), \". If your Dialog content must be a specific predefined width, assign values to both props (or else \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"maxWidth\"), \" \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://css-tricks.com/tale-width-max-width/\"\n  }), \"will take priority\"), \").\"), mdx(\"p\", null, \"The props accept responsive width arrays an well as static strings.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"<DialogManager\\n  content={\\n    <ModalContent>\\n      <Heading>\\n        Resize your browser to watch maxWidth adjust accordingly\\n      </Heading>\\n      <Paragraph>\\n        Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc et eros\\n        sed nisi pellentesque vulputate ac eu augue. Sed commodo sagittis neque,\\n        vel vulputate massa.\\n      </Paragraph>\\n    </ModalContent>\\n  }\\n  /**\\n   * Responsive array values are passed from smallest to largest breakpoints:\\n   */\\n  maxWidth={['90vw', '60vw', '500px', '800px']}\\n>\\n  {open => <Button onClick={open}>Open responsive width modal</Button>}\\n</DialogManager>\\n\")), mdx(\"h2\", null, \"Advanced Use: Protect Unsaved User Changes\"), mdx(\"p\", null, \"If your dialog content includes form inputs it's entirely possible that the user could unintentionally close the dialog and lose their unsaved changes. With careful management of dialog and form state, you can add a second stage dialog to alert the user to unsaved changes and protect them from losing their work.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \";() => {\\n  /**\\n   * Track form input state, and create helper function to compare updated state to default state\\n   */\\n  const defaultFormData = {\\n    name: '',\\n  }\\n  const [formData, setFormData] = useState(defaultFormData)\\n\\n  const hasUnsavedChanges = () => {\\n    if (isEqual(formData, defaultFormData)) {\\n      return false\\n    } else {\\n      return true\\n    }\\n  }\\n\\n  const handleInputChange = e => {\\n    const { name, value } = e.target\\n    setFormData({ ...formData, [name]: value })\\n  }\\n\\n  /**\\n   * Track dialog state: open, close, or cancelling input\\n   */\\n  const [isCancellingInput, setIsCancellingInput] = useState(false)\\n  const [isOpen, setIsOpen] = useState(false)\\n  const handleDialogOpen = () => {\\n    setIsOpen(true)\\n  }\\n\\n  /**\\n   * Create callbacks for the various actions:\\n   * - save\\n   * - cancel\\n   * - confirm close (e.g. \\\"Yes I want to discard my changes and close the dialog\\\")\\n   * - reset form (e.g. \\\"Don't close, let me continue editing\\\")\\n   */\\n\\n  const handleSave = () => {\\n    alert('Saved!') // dispatch side effect\\n    setIsOpen(false) // close dialog\\n    setFormData(defaultFormData) // reset form state\\n  }\\n\\n  const handleCancel = () => {\\n    if (hasUnsavedChanges()) {\\n      // has unsaved changes: keep dialog open and update state to reflect attempt at closing the form\\n      setIsCancellingInput(true)\\n    } else {\\n      // no unsaved changes: close the dialog\\n      setIsOpen(false)\\n    }\\n  }\\n\\n  const handleConfirmClose = () => {\\n    // \\\"Yes I want to discard my changes and close the dialog\\\"\\n    setIsOpen(false) // close form\\n    setIsCancellingInput(false) // reset modal state\\n    setFormData(defaultFormData) // reset form state\\n  }\\n\\n  const handleDialogReset = () => {\\n    setIsCancellingInput(false) // take me back to dialog #1\\n  }\\n\\n  /**\\n   * Render the two dialogs and associated content\\n   */\\n\\n  return (\\n    <>\\n      {/* Trigger dialog open*/}\\n      <Button onClick={handleDialogOpen}>Open user form</Button>\\n      {/*\\n        Dialog #1: User information input\\n      */}\\n      <Dialog\\n        isOpen={isOpen && !isCancellingInput}\\n        onClose={handleCancel}\\n        width=\\\"500px\\\"\\n      >\\n        <ConfirmLayout\\n          title=\\\"Edit Account Information\\\"\\n          message={\\n            <form>\\n              <Heading as=\\\"h3\\\" mb=\\\"small\\\">\\n                Step 1: Enter User Information:\\n              </Heading>\\n              <FieldText\\n                name=\\\"name\\\"\\n                label=\\\"Name\\\"\\n                onChange={handleInputChange}\\n                value={formData.name}\\n              />\\n              <Heading as=\\\"h3\\\">\\n                Step 2: Click <strong>Cancel</strong> to trigger fallback\\n                dialog:\\n              </Heading>\\n            </form>\\n          }\\n          primaryButton={<Button onClick={handleSave}>Save</Button>}\\n          secondaryButton={\\n            <ButtonTransparent onClick={handleCancel}>Cancel</ButtonTransparent>\\n          }\\n        />\\n      </Dialog>\\n      {/* Dialog #2: fallback \\\"discard changes\\\" dialog */}\\n      <Dialog\\n        isOpen={isOpen && isCancellingInput}\\n        onClose={handleConfirmClose}\\n        width=\\\"500px\\\"\\n      >\\n        <ConfirmLayout\\n          title=\\\"Discard Changes?\\\"\\n          titleIcon={<Icon name=\\\"Warning\\\" color=\\\"palette.red500\\\" size={22} />}\\n          message=\\\"Are you sure you want to close the dialog? Unsaved changes will be lost.\\\"\\n          primaryButton={\\n            <ButtonTransparent onClick={handleConfirmClose} color=\\\"danger\\\">\\n              Discard Changes\\n            </ButtonTransparent>\\n          }\\n          secondaryButton={\\n            <ButtonTransparent onClick={handleDialogReset} color=\\\"neutral\\\">\\n              Go Back\\n            </ButtonTransparent>\\n          }\\n        />\\n      </Dialog>\\n    </>\\n  )\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"figma":null,"github":"Modal/Dialog/Dialog","propsOf":"Dialog","status":null,"title":"Dialog"},"tableOfContents":{"items":[{"url":"#standard-use","title":"Standard Use"},{"url":"#dialogmanager","title":"DialogManager"},{"url":"#props-width-and-maxwidth","title":"Props: width and maxWidth"},{"url":"#advanced-use-protect-unsaved-user-changes","title":"Advanced Use: Protect Unsaved User Changes"}]}}},"pageContext":{"id":"8e7349e4-cd4f-5b48-9de1-7f51267ded92"}}}